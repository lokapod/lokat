import { mkdirSync, writeFileSync } from "node:fs"
import { join } from "node:path"
import type { GenerateResult, InputLayout, LocaleCode, Namespace } from "./types.ts"
import { names } from "./util"

function emitKeys(outputDir: string, namespaces: Namespace[], orderByNs: Map<Namespace, string[]>) {
  const lines: string[] = ["// Auto-generated by @lokat/gen", ""]
  for (const ns of namespaces) {
    const enumName = names.formatEnumName(ns)
    const keys = orderByNs.get(ns) || []
    lines.push(`export const enum ${enumName} {`)
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i]
      // Transform key to CONST_CASE-like, but keep alnum and underscores
      const member = k
        .replace(/[^A-Za-z0-9_]/g, "_")
        .replace(/__+/g, "_")
        .toUpperCase()
      lines.push(`  ${member} = ${i},`)
    }
    lines.push("}", "")
  }
  writeFileSync(join(outputDir, "i18n.keys.ts"), lines.join("\n"))
}

function emitArrays(
  outputDir: string,
  layout: InputLayout,
  namespaces: Namespace[],
  locales: LocaleCode[],
) {
  for (const loc of locales) {
    const nsMap = layout.locales.get(loc)
    for (const ns of namespaces) {
      const dict = nsMap?.get(ns)
      if (!dict) continue
      const constName = names.constNameFor(ns, loc)
      const arr = JSON.stringify(Object.values(dict))
      const content = `// Auto-generated by @lokat/gen\nexport const ${constName} = Object.freeze(${arr} as const)`
      writeFileSync(join(outputDir, `${loc}.${ns}.generated.ts`), `${content}\n`)
    }
  }
}

export function emitAll(
  outputDir: string,
  layout: InputLayout,
  res: GenerateResult,
  locales: LocaleCode[],
) {
  mkdirSync(outputDir, { recursive: true })
  emitKeys(outputDir, res.namespaces, res.orderByNs)
  emitArrays(outputDir, layout, res.namespaces, locales)
}
